import { PullTarsTask } from './pullTasks';
import { Cre, damaged, enemySpawn, exist, findTask, getCreeps, getEnemies, getEnemyArmies, getFriends, getMyUnits, inRampart, Role, sasVariables, SOA, spawn, sumForceByArr, tick } from './util';
import { Event, Event_C, validEvent } from './util_event';
import { invalid, last, valid } from './util_JS';
import { atPos, COO, MGR, multiplyVector, myGetRange, P, plusVector, Pos, verticalDistance } from './util_pos';
import { drawLineComplex, SA, SAN } from './util_visual';
/**
 Module: patientSpawnAttacker
 Author: 820491047
 Date:   2022.5.27
 version 0.0.0
*/
import { ATTACK, HEAL, MOVE, RANGED_ATTACK } from 'game/constants';
import { CostMatrix, searchPath } from 'game/path-finder';
import { findClosestByRange } from 'game/utils';

export const patientSpawnAttacker: Role = new Role(
  'patientSpawnAttacker',
  patientSpawnAttackerControl
);

//variables
export let RBRLeader: Cre | undefined | null = null;
export let RBRallInEvent: Event | undefined;
export let RBRallIn: boolean = false;
export let PSAGO: boolean = false;
export let PSAs: Cre[] = [];
export let playerMathI: boolean = false;
export function setPlayerMathI(b: boolean) {
  playerMathI = b;
}
//functions
/**
 * move to a enemy in range
 */
export function moveToEnemyInRange(cre: Cre, pos: Pos, range: number): boolean {
  var ens = getEnemies().filter((i) => myGetRange(i, pos) <= range);
  var en = cre.findClosestByRange(ens);
  if (en) {
    cre.moveToJudge(en);
    return true;
  } else {
    cre.stop();
    return false;
  }
}
function assemblePoint(cre: Cre): Pos {
  let ind: number = (<any>cre).psInd;
  let lr = multiplyVector(sasVariables.leftVector(), -3);
  let v1: Pos;
  if (ind == 0) v1 = { x: spawn.x - 1, y: spawn.y };
  else if (ind == 1) v1 = { x: spawn.x, y: spawn.y };
  else if (ind == 2) v1 = { x: spawn.x - 1, y: spawn.y + 1 };
  else if (ind == 3) v1 = { x: spawn.x + 1, y: spawn.y + 1 };
  else if (ind == 4) v1 = { x: spawn.x, y: spawn.y + 1 };
  else if (ind == 5) v1 = { x: spawn.x + 1, y: spawn.y };
  else if (ind == 6) v1 = { x: spawn.x, y: spawn.y - 1 };
  else v1 = { x: spawn.x, y: spawn.y - 2 };
  return plusVector(v1, lr);
}
export const PSATotalNum = 8;
function ifGo(cre: Cre, psas: Cre[]): boolean {
  return (
    tick >= 440 ||
    (psas.length >= PSATotalNum &&
      MGR(psas[PSATotalNum - 1], assemblePoint(cre)) === 0)
  );
}
/**
 * control a creep as a patient spawn attacker.it will wait at base at <400 tick.
 * and drive a train to the enemy base.if is at enemy base or num of creeps has healthy move part
 * less than 3.it will split.and then attack the enemy spawn.
 */
export function patientSpawnAttackerControl(cre: Cre) {
  let psas: Cre[] = getFriends().filter(
    (i) => i.role == patientSpawnAttacker && i.isBirth
  );
  // SA(cre,"psas.length="+psas.length)
  if ((<any>cre).psInd == undefined) {
    (<any>cre).psInd = psas.length - 1;
    PSAs.push(cre);
  }
  SA(cre, 'psInd=' + (<any>cre).psInd);
  if (ifGo(cre, psas)) PSAGO = true;
  if (!PSAGO) {
    //if not go to attack enemy spawn
    if (tick >= 370) {
      //if tick>=320 && tick<=400
      let tar = assemblePoint(cre);
      cre.moveToJudge(tar);
    } else {
      //if tick<320
      if (cre.getBodies(HEAL).length > 0) {
        let myUnits = getMyUnits();
        let scanRange = 10;
        let tars = myUnits.filter(
          (i) => myGetRange(cre, i) <= scanRange && damaged(i)
        );
        if (tars.length > 0) {
          let tar = cre.findClosestByRange(tars);
          if (tar) cre.MTJ(tar);
          cre.restore();
        } else {
          let tar = assemblePoint(cre);
          cre.moveToJudge(tar);
        }
      } else {
        let scanRange = cre.getBodies(RANGED_ATTACK).length > 0 ? 10 : 7;
        let b = moveToEnemyInRange(cre, spawn, scanRange);
        if (!b) {
          let tar = assemblePoint(cre);
          cre.moveToJudge(tar);
        }
      }
    }
  } else {
    //if on the way to enemy spawn
    let psasReSort: Cre[] = [];
    if (exist(PSAs[3])) psasReSort.push(PSAs[3]);
    if (exist(PSAs[4])) psasReSort.push(PSAs[4]);
    if (exist(PSAs[2])) psasReSort.push(PSAs[2]);
    if (exist(PSAs[0])) psasReSort.push(PSAs[0]);
    if (exist(PSAs[1])) psasReSort.push(PSAs[1]);
    if (exist(PSAs[5])) psasReSort.push(PSAs[5]);
    if (exist(PSAs[6])) psasReSort.push(PSAs[6]);
    if (exist(PSAs[7])) psasReSort.push(PSAs[7]);
    //
    let psasH = psasReSort.filter((i) => i.getHealthyBodies(MOVE).length > 0);
    let leader: Cre = psasReSort[0];
    let j0 = !exist(RBRLeader);
    let j1 = RBRLeader != null;
    let j2 = leader == cre;
    // SA(cre,"j0="+j0)
    // SA(cre,"j1="+j1)
    // SA(cre,"j2="+j2)
    //control leader PSA
    if (psasH.length < 3) {
      //if healthy PSA <3
      RBRallIn = true;
      SA(cre, 'RBRallIn=' + RBRallIn);
    } else if ((PSAGO || (j0 && j1)) && j2) {
      //if leader==cre && rush to enemyspawn
      if (PSAGO) {
        for (let psa of psasReSort) {
          psa.stop();
        }
      }
      SA(cre, 'psasReSort.length=' + psasReSort.length);
      SA(cre, 'psasH.length=' + psasH.length);
      if (psasH.length >= 3) {
        let followers = psasReSort.filter((i) => i != leader);
        SA(cre, 'leader=' + COO(leader));
        SA(cre, 'followers=' + SOA(followers));
        new PullTarsTask(leader, followers, enemySpawn, undefined, false);
        RBRLeader = leader;
      } else {
        RBRallIn = true;
        SA(cre, 'RBRallIn=' + RBRallIn);
      }
    }
    //control normal PSA
    let split: boolean;
    let roundEnemies = getEnemies().filter((i) => MGR(i, cre) <= 1);
    let roundEnemyForce: number = sumForceByArr(roundEnemies);
    //judge if split
    let roundEnemyForceBias = 25;
    let MGRLargeBias = 35;
    if (playerMathI) {
      MGRLargeBias = 45;
    }
    SA(cre, 'MGR(leader,enemySpawn)=' + MGR(leader, enemySpawn));
    SA(
      cre,
      'verticalDistance(leader,enemySpawn)=' +
        verticalDistance(leader, enemySpawn)
    );
    SA(cre, 'roundEnemyForce=' + roundEnemyForce);
    const roundForce1 = sumForceByArr(
      getEnemyArmies().filter((i) => MGR(i, leader) <= 1)
    );
    const roundForce5 = sumForceByArr(
      getEnemyArmies().filter((i) => MGR(i, leader) <= 5)
    );
    const leaderDanger: number = roundForce1 + 0.4 * roundForce5;
    SAN(leader, 'leaderDanger', leaderDanger);
    if (RBRallIn) {
      split = true;
      let pt = findTask(leader, PullTarsTask);
      if (pt) {
        pt.end();
      }
    } else if (
      //judge if split by position
      MGR(leader, enemySpawn) <= 2 ||
      (MGR(leader, enemySpawn) <= 6 &&
        (leader.getMoveTime() > 1 || roundEnemyForce >= 25)) ||
      (verticalDistance(leader, enemySpawn) <= 20 &&
        roundEnemyForce >= roundEnemyForceBias)
    ) {
      split = true;
      RBRallIn = true;
    } else if (
      (leaderDanger >= 20 && verticalDistance(leader, enemySpawn) <= 15) ||
      leaderDanger >= 90
    ) {
      split = true;
      RBRallIn = true;
    } else {
      split = false;
    }
    // SA(cre,"split="+split)
    //
    if (split) {
      //if split
      if (invalid(RBRallInEvent)) {
        RBRallInEvent = new Event_C();
      }
      const dangerousFriend = getFriends().find((i) =>
        valid(getEnemyArmies().find((j) => MGR(i, j) <= 1))
      );
      const closesetToEnS = findClosestByRange(enemySpawn, getFriends());
      let waitTime: number = 7;
      if (MGR(cre, enemySpawn) <= 8) {
        waitTime = 7;
      } else {
        if (cre.getSpeed() === 1) {
          waitTime = 9;
        } else {
          waitTime = 24;
        }
      }
      if (invalid(dangerousFriend) && validEvent(RBRallInEvent, waitTime)) {
        cre.moveToNormal(closesetToEnS);
      } else {
        let isRA: boolean =
          cre.getBodies(RANGED_ATTACK).length > 0 &&
          cre.getBodies(ATTACK).length == 0;
        if (isRA) {
          //RA
          if (myGetRange(cre, enemySpawn) <= 3) {
            cre.stop();
            let enemiesInRange = getEnemies().filter(
              (i) => myGetRange(i, cre) <= 3
            );
            if (enemiesInRange.length > 0) {
              SA(cre, 'en exist');
              try {
                let tarOOA: { pos: Pos; range: number }[] = [];
                for (let en of enemiesInRange) {
                  tarOOA.push({ pos: en, range: 4 });
                }
                let tar = searchPath(cre, tarOOA, { flee: true }).path;
                if (tar.length > 0) {
                  SA(cre, 'tar[0]=' + COO(tar[0]));
                  SA(cre, 'tar[last]=' + COO(last(tar)));
                  cre.moveTo(tar[0]);
                }
              } catch (ex) {
                P(ex);
              }
            } else {
              SA(cre, 'stop');
            }
          } else {
            if (sasVariables.inEnBaseRan(cre)) {
              cre.stop();
              cre.moveTo(enemySpawn);
            } else {
              cre.moveToJudge(enemySpawn);
            }
          }
        } else {
          //A
          if (myGetRange(cre, enemySpawn) <= 1) {
            cre.stop();
          } else {
            //at 13 vertical
            let target: Pos | undefined;
            if (sasVariables.inEnBaseRan(cre)) {
              let threatenEn = getEnemies().find(
                (i) =>
                  MGR(i, cre) <= 4 &&
                  i.getBodies(ATTACK).length > 0 &&
                  MGR(i, enemySpawn) <= MGR(cre, enemySpawn) + 3 &&
                  !atPos(i, enemySpawn) &&
                  !inRampart(i)
              );
              if (threatenEn) {
                target = threatenEn;
              } else {
                target = enemySpawn;
              }
            } else {
              target = enemySpawn;
            }
            //avoid block by friend at small road
            if (MGR(cre, enemySpawn) >= 4) {
              SA(cre, 'move careful');
              const tempCM = new CostMatrix();
              const creeps = getCreeps();
              for (let everyCre of creeps) {
                tempCM.set(everyCre.x, everyCre.y, 30);
              }
              const tempTar = searchPath(cre, target, {
                costMatrix: tempCM,
                plainCost: 1,
                swampCost: 3,
              }).path[0];
              drawLineComplex(cre, tempTar, 0.7, '#553477');
              cre.moveTo_follow(tempTar);
            } else {
              const sRtn = cre.getDecideSearchRtnByCre(target);
              const tarPos = sRtn.path[0];
              const enRam = getEnemies().find(
                (i) =>
                  MGR(tarPos, i) <= 1 &&
                  i.getBodiesNum(ATTACK) >= 3 &&
                  inRampart(i) &&
                  !atPos(i, enemySpawn)
              );
              if (enRam) {
                SA(cre, 'i m wrong');
                cre.stop();
              } else {
                SA(cre, 'i m right');
                cre.moveToNormal(tarPos);
              }
            }
          }
        }
      }
    } else {
      //not split
    }
  }
  cre.meleeAndShotAndRestore();
  // cre.melee();
  // cre.shot();
  // if((!hasOppoUnitsAround(cre)||cre.getHealthyBodies(ATTACK).length==0)){
  // 	cre.restore()
  // }
}

//turtle
/**
 Module: turtle
 Author: 820491047
 Date:   2022.7.16
 version 0.0.1
*/
import { BOTTOM, CARRY, DirectionConstant, LEFT, RIGHT, TOP, WORK } from "game/constants";
import { Creep, GameObject, StructureContainer, StructureRampart, StructureRoad, StructureSpawn, StructureWall } from "game/prototypes";
import { findClosestByPath, getDirection } from "game/utils";
import { body3C3W3M, bodyM3AM4AM, harvesterBody, moveToRampart, spawnAttacker } from "../armies";
import { builder } from "../builder";
import { addStrategyTick, defender_rampart } from "../defender";
import { harvester } from "../harvester";
import { moveToEnemyInRange, patientSpawnAttacker, PSATotalNum, setPlayerMathI } from "../patientSpawnAttacker";
import { Capta, Dooms, getGuessPlayer, MathI, playerJudgedCapta, playerJudgedDooms, playerJudgeMathI, set_playerJudgedCapta, set_playerJudgedDooms, set_playerJudgeMathI, Tigga } from "../player";
import { toughDefender } from "../toughDefender";
import { blocked, canBeBuildByCre, createCS, CS, ct, enemyAWeight, findMaxTaunt, GAB, GB, getCapacity, getClosestEnemy, getContainers, getCPUPercent, getDecideSearchRtnNoArea, getEnergy, getFreeEnergy, getHarvestables, getIsBuilding, getMaxWorthCSS, getMyConstructionSites, getOppoExtensions, getOppoUnits, getSurfaceBody, getTaunt, getWalls, GHB, GMB, GRB, GTB, hasEnemyArmyAround, hasEnemyArmyAtPos, hasFriendAround, HasStore, isMyTick, isMyUnit, isOppoUnit, isTerrainSwamp, isTerrainWall, live, pt, reBuildAroundRampart, reBuildBaseRampart, reBuildCrossRampart, setEnSpawnAroundCost, setMoveMapSetRate, setResourceDrop, setSpawnDps, spawnCreep, spawnCreepInFront, SpawnInfo, spawnList } from "../util";
import { Event_Number } from "../util_event";
import { first } from "../util_JS";
import { overallMap } from "../util_MyMap";
import { getRangePoss, inBorder, leftRotate, minusVector, pos00, rightRotate, validPos } from "../util_pos";
import { drawLineLight, drawPoly } from "../util_visual";
import { builderTurtleJob } from "./turtle";
//Role
export const defenderTurtle: Role = new Role(
  "defenderTurtle",
  defenderTurtleJob
);
export const builderTurtle: Role = new Role("builderTurtle", builderTurtleJob);
export const harvesterTurtle: Role = new Role("harvester", harvesterTurtleJob);

//functions
export function defenderTurtleJob(cre: Cre) {
  cre.meleeAndShotAndRestore();
  moveToRampart(cre, getClosestEnemy(cre));
}

export function builderTurtleJob(cre: Cre): void {
  // if(tick<=600){
  //judge if can build
  let css = <CS[]>(
    getMyConstructionSites().filter((i) => canBeBuildByCre(i, cre))
  );
  let cs = getMaxWorthCSS(css);
  if (cs) {
    if (getIsBuilding(cre)) {
      SA(cre, "directBuild");
      cre.directBuild(cs);
    } else if (tick <= 300) {
      SA(cre, "collectResource");
      let harvables = getHarvestables()
        .filter((i) => MGR(i, spawn) <= 3)
        .concat(spawn);
      let harvable = cre.findClosestByRange(harvables);
      if (harvable) {
        cre.directWithdraw(harvable);
      }
    } else {
      SA(cre, "directWithdraw");
      let baseLiveContainers = getBaseContainers().filter((i) => live(i));
      let tar: HasStore | undefined | null;
      if (getEnergy(spawn) <= 50) {
        tar = cre.findClosestByRange(baseLiveContainers);
      } else {
        tar = spawn;
      }
      if (tar) cre.directWithdraw(tar);
    }
  } else {
    moveToRampart(cre, undefined);
  }
  // }else{

  // }
}
export function harvesterTurtleJob(cre: Cre) {
  if (tick >= 300) {
    cre.MTJ(enemySpawn);
    return;
  }
  if (getEnergy(cre) == 0) {
    // have not energy
    // SA(cre,'have not energy')
    let wRtn = cre.withdrawFromHarvestable();
    if (wRtn) {
      if (getCapacity(cre) <= 100 && !isTerrainSwamp(cre)) {
        //if carry <=100 walk a step
        SA(cre, "quickly transToProducers");
        transToSpawnAndBaseContainer(cre);
      } else {
        SA(cre, "movePause");
        cre.movePause();
      }
    }
  } else {
    //have energy
    //drop and move
    SA(cre, "drop and move");
    if (cre.getMoveTime() > 2) {
      //if en > 100 drop
      // SA(cre,'transToProducers pick drop')
      let tRtn = transToSpawnAndBaseContainer(cre);
      if (!tRtn) {
        //if not trans success
        cre.dropEnergy(); //drop it on ground
        setResourceDrop(cre);
        cre.moveContinue();
      } else {
        cre.withdrawFromHarvestable();
      }
    } else {
      //if en <= 100
      // SA(cre,'transToProducers normal')
      let tRtn = transToSpawnAndBaseContainer(cre);
      if (tRtn) {
        cre.withdrawFromHarvestable();
      }
    }
  }
}
function getBaseContainers(): StructureContainer[] {
  return getContainers().filter((i) => MGR(i, spawn) <= 1);
}
function transToSpawnAndBaseContainer(cre: Cre): boolean {
  let tar: HasStore | undefined;
  if (getEnergy(spawn) < 1000) {
    tar = spawn;
  } else {
    const freeLimit = 1200;
    let baseContainers = getBaseContainers();
    let freeBaseContainers = baseContainers.filter(
      (i) => getEnergy(i) < freeLimit
    );
    let freeBaseContainer = cre.findClosestByRange(freeBaseContainers);
    if (freeBaseContainer) {
      tar = freeBaseContainer;
    } else {
      tar = spawn;
    }
  }
  drawLineLight(cre, tar);
  if (getFreeEnergy(tar) == 0) {
    //if producer is full
    return cre.directDrop(tar); //drop at producer
  } else {
    //if not full,transfer to it
    return cre.directTransfer(tar);
  }
}
function buildContainer() {
  let pos1 = { x: spawn.x, y: spawn.y + 1 };
  let pos2 = { x: spawn.x, y: spawn.y - 1 };
  createCS(pos1, StructureContainer, 11, false);
  createCS(pos2, StructureContainer, 11, false);
}
function rebuildWall3() {
  let rangePos = getRangePoss(spawn, 3);
  for (let pos of rangePos) {
    if (MGR(pos, spawn) == 3 && getMyConstructionSites().length <= 7) {
      let r = createCS(pos, StructureWall, 5, false, false);
      if (r) break;
    }
  }
}
function buildBaseRampart() {
  createCS(spawn, StructureRampart, 10, false, true);
  createCS(spawn, StructureRampart, 10, false, true);
  createCS(spawn, StructureRampart, 10, false, true);
}
function rebuildBaseRampartAround() {
  //changed to not build wall
  let rangePos = getRangePoss(spawn, 1);
  for (let pos of rangePos) {
    if (!hasEnemyArmyAtPos(pos) && getMyConstructionSites().length <= 7) {
      let r = createCS(pos, StructureRampart, 9, false, false);
      if (r) break;
    }
  }
}
//## KEY
export function useTurtleStrategy() {
  if (tick == 1) {
    // create creeps
    spawnCreep(harvesterBody, harvesterTurtle);
    spawnCreep(harvesterBody, harvesterTurtle);
    spawnCreep(harvesterBody, harvesterTurtle);
    spawnCreep(body3C3W3M, builderTurtle);
  }
  if (tick == 4) {
    buildBaseRampart();
  }
  if (tick == 10) {
    buildContainer();
  }
  if (tick == 30) {
    // tick 2
    spawnCreep(bodyM3AM4AM, defenderTurtle);
  }
  if (tick == 40) {
    // tick 2
    spawnCreep(bodyM3AM4AM, defenderTurtle);
  }
  if (tick >= 50) {
    rebuildBaseRampartAround();
  }
  if (tick >= 150) {
    rebuildWall3();
  }
}
//##

//robot
@@ -1,1158 +0,0 //variables
let assemblePos: Pos = pos00;
let targetAssemblePos: Pos = pos00;
let allRPprepared: boolean = false;
//
let cm: CostMatrix = new CostMatrix();
let currentPath: Pos[] | undefined;
const snakeMode = "snakeMode";
const splitMode = "splitMode";
const standardMode = "standardMode";
let useRobotMode = standardMode;
let useHarvestStrategy: boolean = false;
//Roles
const robotPart: Role = new Role("robotPart", robotPartJob);
const extAttacker: Role = new Role("extAttacker", extAttackerJob);
//type
type Direct4 = typeof TOP | typeof BOTTOM | typeof LEFT | typeof RIGHT;
//classes
class Shape {
  name: string;
  rotate: Direct4;
  we: Event_Number = new Event_Number(0);
  constructor(name: string, rotate: Direct4) {
    this.name = name;
    this.rotate = rotate;
  }
  equal(shape: Shape) {
    return this.name === shape.name && this.rotate === shape.rotate;
  }
  toString() {
    return this.name + ":" + this.rotate;
  }
}
//shapes
const shapeType_normal: string = "shapeType_normal";
const shapeType_beta: string = "shapeType_beta";
const shapeType_corner: string = "shapeType_corner";
const shape_top: Shape = new Shape(shapeType_normal, TOP);
const shape_bottom: Shape = new Shape(shapeType_normal, BOTTOM);
const shape_left: Shape = new Shape(shapeType_normal, LEFT);
const shape_right: Shape = new Shape(shapeType_normal, RIGHT);
const shape_top_beta: Shape = new Shape(shapeType_beta, TOP);
const shape_bottom_beta: Shape = new Shape(shapeType_beta, BOTTOM);
const shape_left_beta: Shape = new Shape(shapeType_beta, LEFT);
const shape_right_beta: Shape = new Shape(shapeType_beta, RIGHT);
const shape_topLeft: Shape = new Shape(shapeType_corner, TOP);
const shape_topRight: Shape = new Shape(shapeType_corner, RIGHT);
const shape_bottomLeft: Shape = new Shape(shapeType_corner, LEFT);
const shape_bottomRight: Shape = new Shape(shapeType_corner, BOTTOM);
const shapeList: Shape[] = [
  shape_top,
  shape_bottom,
  shape_left,
  shape_right,
  shape_top_beta,
  shape_bottom_beta,
  shape_left_beta,
  shape_right_beta,
  shape_topLeft,
  shape_topRight,
  shape_bottomLeft,
  shape_bottomRight,
];
//
/** must give a new Shape to it */
let currentShape: Shape = new Shape(shapeType_normal, TOP);
let everLastingSnakeMode: boolean = false;
//functions
function getBestShape(): Shape {
  let maxW: number = -1;
  let rtn: Shape = currentShape;
  const sameBias = 40;
  for (let shape of shapeList) {
    let w = shape.we.getFreshNum();
    if (shape.equal(currentShape)) {
      w += sameBias;
    }
    if (w > maxW) {
      maxW = w;
      rtn = shape;
    }
  }
  return rtn;
}
function isDirection4(dir: DirectionConstant): boolean {
  return dir === TOP || dir === BOTTOM || dir === LEFT || dir === RIGHT;
}
/**
 * rotate direction clock wise
 */
function rotateDirectionCW(
  dir: DirectionConstant,
  n: number
): DirectionConstant {
  if (Math.floor(n) != n) {
    P("ERR rorateDir");
    return 1;
  } else {
    let dirpnm1 = dir + n - 1;
    // if(dirpnm1>=0)
    //     return <DirectionConstant>(dirpnm1 % 8+1)
    // else
    return <DirectionConstant>(((dirpnm1 + 8 * 100) % 8) + 1);
  }
}
function setTargetAssemblePos() {
  if (useHarvestStrategy) {
    targetAssemblePos = enemySpawn;
  } else {
    targetAssemblePos = enemySpawn;
  }
}
function getShapeConstByRotate(dir: DirectionConstant): Shape {
  if (isDirection4(dir)) {
    return <Shape>(
      shapeList.find((i) => i.name === "shapeType_normal" && i.rotate === dir)
    );
  } else {
    return <Shape>(
      shapeList.find(
        (i) =>
          i.name === "shapeType_corner" &&
          i.rotate === rotateDirectionCW(dir, 1)
      )
    );
  }
}
function atCorrectPos(cre: Cre): boolean {
  return atPos(getCorrectPos(cre), cre);
}
function getCorrectPos(cre: Cre): Pos {
  let ind = getRPInd(cre);
  return assemblePoint_Robot(ind, assemblePos);
}
function getRPInd(cre: Cre): number {
  let ind: number = cre.spawnInfo?.extraMessage.ind;
  return ind;
}
function setRPInd(cre: Cre, n: number): void {
  SA(assemblePos, "set " + COO(cre) + " newInd=" + n);
  (<SpawnInfo>cre.spawnInfo).extraMessage.ind = n;
}
function doDefend(cre: Cre): boolean {
  if (cre.getBodies(HEAL).length > 0) {
    let myUnits = getMyUnits();
    let scanRange = 10;
    let tars = myUnits.filter((i) => MGR(cre, i) <= scanRange && damaged(i));
    if (tars.length > 0) {
      let tar = cre.findClosestByRange(tars);
      if (tar) cre.MTJ(tar);
      cre.restore();
      return true;
    } else {
      return false;
    }
  } else {
    let scanRange = cre.getBodies(RANGED_ATTACK).length > 0 ? 10 : 7;
    let b = moveToEnemyInRange(cre, spawn, scanRange);
    return b;
  }
}
function startAssault(cre: Cre) {
  let ind: number = getRPInd(cre);
  //split mode
  if (useRobotMode === splitMode) {
    SA(cre, "split mode action");
    let tars: Cre[] | undefined;
    //healer
    if (ind === 5 && cre.getBodiesNum(ATTACK) === 0) {
      SA(cre, "healer movement");
      tars = getFriends().filter(
        (i) => MGR(i, cre) <= 4 && damaged(i) && MGR(i, assemblePos) <= 4
      );
      //attacker
    } else {
      const attackerTars = getEnemyArmies().filter(
        (i) =>
          MGR(i, cre) <= 4 &&
          i.getBodiesNum(ATTACK) > 0 &&
          MGR(i, assemblePos) <= 4 &&
          !atPos(i, enemySpawn) &&
          !inRampart(i)
      );
      const tars1 = attackerTars.filter((i) => MGR(i, cre) <= 1);
      const tars2 = attackerTars.filter((i) => MGR(i, cre) <= 2);
      if (tars1.length === 0) {
        //only attack one who adjacent to friend
        if (tars2.length === 0) {
          SA(cre, "chase movement");
          tars = attackerTars;
        } else {
          const tars2Filter = getEnemyArmies().filter(
            (i) =>
              MGR(i, cre) <= 2 &&
              hasFriendAround(i, 1) &&
              i.getBodiesNum(ATTACK) > 0 &&
              MGR(i, assemblePos) <= 4
          );
          SA(cre, "stay movement");
          tars = tars2Filter;
        }
      } else {
        SA(cre, "attack movement");
        tars = tars1;
      }
    }
    //get tar that is closest
    const tar = findClosestByPath(cre, tars, { maxOps: 400 });
    if (tar)
      if (MGR(cre, tar) <= 1 && tar.fatigue !== 0) {
        //if tar can not move next tick
        SA(cre, "find better tar");
        const checkPoss = getRangePoss(cre, 1).filter(
          (i) => !blocked(i) && MGR(i, tar) === 1
        );
        for (let pos of checkPoss) {
          const aroundEn = getEnemies().filter((i) => MGR(i, pos) <= 1);
          const rtnFMT = findMaxTaunt(aroundEn);
          const maxTaunt = rtnFMT.taunt;
          if (rtnFMT.unit && maxTaunt > getTaunt(tar)) {
            SA(cre, "better tar success");
            SA(rtnFMT.unit, "better tar pos");
            cre.moveTo_follow(rtnFMT.unit);
            break;
          }
        }
      } else {
        SA(cre, "move to follow");
        cre.moveTo_follow(tar);
      }
    //if have no tar
    else {
      if (getRobotParts().length >= 3) {
        SA(cre, "no tar stop");
        cre.stop();
      } else {
        SA(cre, "rush enemy spawn");
        cre.MTJ(enemySpawn);
      }
      // cre.moveTo_follow(getCorrectPos(cre))
    }
    //     && i.getBodiesNum(ATTACK)>0)
    // const closeEn=getEnemyArmies().find(i=>MGR(i,cre)<=1
    //     && i.getBodiesNum(ATTACK)>0)
    // if(closeEn){
    //     cre.moveTo_follow(closeEn)
    // }else{
    //     const tar=cre.findFitOppoUnit(2,3)
    //     if(tar){
    //         cre.moveTo_follow(tar)
    //     }
    // }
    //snake mode
  } else if (useRobotMode === snakeMode) {
    SA(cre, "snake mode action");
    let rpf = getRpFirst();
    if (MGR(cre, enemySpawn) <= 1) {
      cre.stop();
    } else if (MGR(cre, enemySpawn) <= 8) {
      cre.MTJ(enemySpawn);
    } else if (rpf && MGR(rpf, enemySpawn) <= 1) {
      cre.MTJ(enemySpawn);
    } else if (rpf && ind === getRPInd(rpf)) {
      let tars = getRobotParts().filter((i) => i !== cre);
      let pathRP: Pos[] | undefined;
      let testpathRP: Pos[] | undefined;
      if (everLastingSnakeMode) {
        pathRP = searchPath(rpf, enemySpawn).path;
        testpathRP = rpSearchPath();
      } else {
        pathRP = rpSearchPath();
        testpathRP = pathRP;
      }
      let lpq = last(testpathRP);
      //last point
      let lp = lpq ? lpq : targetAssemblePos;
      if (MGR(lp, targetAssemblePos) >= 5) {
        everLastingSnakeMode = true;
      } else {
        everLastingSnakeMode = false;
      }
      const lenLimit = 15;
      if (!findTask(cre, PullTarsTask) || isMyTick(cre, 7)) {
        if (pathRP.length >= lenLimit && !everLastingSnakeMode) {
          new PullTarsTask(cre, tars, pathRP[lenLimit - 1]);
        } else {
          new PullTarsTask(cre, tars, targetAssemblePos);
        }
      }
    } else {
    }
    //if is standardMode
  } else if (useRobotMode === standardMode) {
    SA(cre, "standard mode action");
    //end the snake task
    findTask(cre, PullTarsTask)?.end();
    //
    let asP = getCorrectPos(cre);
    //if not at correct pos
    if (!atPos(asP, cre)) {
      SA(cre, "not at correct pos");
      //if range 1 direct go to it
      if (MGR(asP, cre) <= 1) {
        SA(cre, "adjacent tile");
        cre.moveToNormal(asP);
      } else {
        //if range >=2
        let sRtn = getDecideSearchRtnNoArea(cre, asP);
        //if cannot reach
        if (sRtn.incomplete) {
          SA(cre, "sRtn.incomplete");
          let blockCre = getRobotParts().find((i) => MGR(cre, i) <= 1);
          // move block cre
          if (blockCre) {
            blockCre.moveToNormal(cre);
            cre.moveToNormal(blockCre);
          }
        }
        SA(cre, "moveToNormal");
        //move direct
        cre.moveToNormal(<Pos>first(sRtn.path));
      }
    }
    //if there is blocked friend attack it or move it
    let f: Cre | undefined = <Cre | undefined>(
      overallMap
        .get(asP)
        .find(
          (i) =>
            i instanceof Creep && isMyUnit(i) && (<Cre>i).role !== robotPart
        )
    );
    if (f) {
      if (f.getMoveTime() < 5) {
        f.MTJ(spawn);
      } else {
        cre.attack(f);
        cre.shotTarget(f);
      }
    }
    // let rps=getRobotParts()
    // if(rps.length===6){
    //     //if all RPs ready
    //     if(allReady(rps)){
    //         let rp:Cre|undefined=<Cre|undefined>overallMap
    //             .get(asP).find(i=>i instanceof Creep
    //                  && isMyUnit(i)
    //                  && (<Cre>i).role===robotPart);
    //         (<any>cre).rpsAtFront=rp
    //         if((<any>cre).rpsAtFront){
    //             (<any>cre).rpsAtFront.normalPull(cre)
    //         }
    //     //if all at correct pos
    //     }else if(ifAllAtCorrectPos(rps)){
    //         if((<any>cre).rpsAtFront){
    //             (<any>cre).rpsAtFront.normalPull(cre)
    //         }

    //     }
    // }
  }
}
function ifMovable(cre: Cre): boolean {
  return cre.fatigue == 0;
}
function ifAllMovable(cres: Cre[]): boolean {
  let rtn = true;
  for (let cre of cres) {
    if (!ifMovable(cre)) {
      rtn = false;
    }
  }
  return rtn;
}
function robotPartJob(cre: Cre) {
  let ind: number = getRPInd(cre);
  SA(cre, "ind=" + ind);
  //get assemble point of robot
  let asP: Pos = assemblePoint_Robot(ind, assemblePos);
  let rps = getFriends().filter((i) => i.role == robotPart);
  let rpNum = rps.length;
  let rpPNum = rps.filter((i) => atCorrectPos(i)).length;
  if (tick >= 380 || (rpNum >= 6 && rpPNum >= 6)) {
    allRPprepared = true;
  }
  if (allRPprepared) {
    SA(cre, "Pre");
    startAssault(cre);
  } else {
    SA(cre, "Wait");
    let ifDo: boolean;
    if (tick >= 290) {
      ifDo = false;
    } else {
      ifDo = doDefend(cre);
    }
    if (ifDo) {
      SA(cre, "Defend");
    } else {
      cre.MTJ(asP);
    }
  }
  cre.meleeAndShotAndRestore();
}
function buildBaseDefending() {
  //100+50+160+150+50
  spawnCreep([ATTACK, ATTACK, RANGED_ATTACK, WORK, CARRY, MOVE, MOVE], builder); //200
  createCS(spawn, StructureRampart, 10, false, true);
  createCS({ x: spawn.x, y: spawn.y + 1 }, StructureRampart, 10);
  createCS({ x: spawn.x, y: spawn.y - 1 }, StructureRampart, 10);
  createCS({ x: spawn.x + 1, y: spawn.y }, StructureRampart, 10);
  createCS({ x: spawn.x - 1, y: spawn.y }, StructureRampart, 10);

  // createConstructionSiteAndCancel(getBuilderLocation(),StructureRampart,10);
}
function extAttackerJob(cre: Cre) {
  cre.melee();
  const scanRange1 = 15;
  let ensAround = getEnemyArmies().filter((i) => MGR(i, cre) <= scanRange1);
  if (ensAround.length > 0) {
    const scanRange2 = 12;
    let ensAround2 = getEnemyArmies().filter((i) => MGR(i, cre) <= scanRange2);
    if (ensAround2.length > 0) {
      cre.flee(scanRange2, 26);
    } else {
      let tarPos = plusVector(
        spawn,
        multiplyVector(sasVariables.leftVector(), 3)
      );
      cre.MTJ(tarPos);
    }
  } else {
    let opExts = getOppoExtensions();
    let builders = getEnemies().filter((i) => i.getBodies(WORK).length > 0);
    let ext = cre.findClosestByRange(opExts);
    let extT = 2 * (ext ? 1 / (MGR(ext, cre) + 1) : 0);
    let buider = cre.findClosestByRange(builders);
    let buiT = buider ? 1 / (MGR(buider, cre) + 1) : 0;
    if (ext && extT > buiT) {
      cre.MTJ(ext);
    } else if (buider && buiT > extT) {
      cre.MTJ(buider);
    }
  }
}
function assemblePoint_Robot(ind: number, leaderPos: Pos): Pos {
  let rtn: Pos = leaderPos;
  if (
    currentShape.name == shapeType_normal ||
    currentShape.name == shapeType_beta
  ) {
    if (ind == 1) rtn = plusVector(rtn, { x: -1, y: 0 });
    else if (ind == 2) rtn = plusVector(rtn, { x: 0, y: 0 });
    else if (ind == 3) rtn = plusVector(rtn, { x: 1, y: 0 });
    else if (ind == 4) rtn = plusVector(rtn, { x: 1, y: 1 });
    else if (ind == 5) rtn = plusVector(rtn, { x: 0, y: 1 });
    else if (ind == 6) rtn = plusVector(rtn, { x: -1, y: 1 });
    else {
      P("RPIndexError");
    }
    if (currentShape.name == shapeType_beta) {
      rtn = plusVector(rtn, { x: 0, y: -1 });
    }
  } else if (currentShape.name == shapeType_corner) {
    if (ind == 1) rtn = plusVector(rtn, { x: -1, y: 0 });
    else if (ind == 2) rtn = plusVector(rtn, { x: -1, y: -1 });
    else if (ind == 3) rtn = plusVector(rtn, { x: 0, y: -1 });
    else if (ind == 4) rtn = plusVector(rtn, { x: 1, y: 0 });
    else if (ind == 5) rtn = plusVector(rtn, { x: 0, y: 0 });
    else if (ind == 6) rtn = plusVector(rtn, { x: 0, y: 1 });
    else {
      P("RPIndexError");
    }
  } else {
    rtn = enemySpawn;
    P("ShapeError");
  }
  rtn = getRotate(rtn, currentShape.rotate, assemblePos);
  return rtn;
}
function getRotate(pos: Pos, dir: Direct4, midPoint: Pos): Pos {
  if (dir === TOP) {
    return pos;
  } else if (dir == BOTTOM) {
    let dr = minusVector(pos, midPoint);
    return minusVector(midPoint, dr);
  } else if (dir == LEFT) {
    let dr = minusVector(pos, midPoint);
    let ndr = leftRotate(dr);
    return plusVector(midPoint, ndr);
  } else if (dir == RIGHT) {
    let dr = minusVector(pos, midPoint);
    let ndr = rightRotate(dr);
    return plusVector(midPoint, ndr);
  } else {
    P("DIRERROR");
    return pos;
  }
}
function initCM() {
  for (let i = 0; i < 100; i++) {
    if (getCPUPercent() > 0.7) {
      P("initCM BREAK");
      return;
    }
    for (let j = 0; j < 100; j++) {
      let pos = { x: i, y: j };
      let possAround = getRangePoss(pos, 1);
      let possAround2 = getRangePoss(pos, 2);
      // let block:boolean=false
      //
      let cost: number = 1;
      for (let posA of possAround) {
        if (!inBorder(posA) || isTerrainWall(posA)) {
          // block=true
          cost += 255;
        } else if (isTerrainSwamp(posA)) {
          cost += 4;
        }
      }
      for (let posA of possAround2) {
        let ol = overallMap.get(posA);
        let ram = ol.find(
          (i) => i instanceof StructureRampart && isOppoUnit(i)
        );
        if (ram) {
          if (MGR(posA, enemySpawn) <= 1) {
            cost += 15;
          } else {
            cost += 50;
          }
        }
      }
      // cost*=0.3
      // for(let posA of possAround){
      //     if(!inBorder(posA) ||isTerrainWall(posA)){
      //         block=true
      //     }else{
      //         cost+=0.7/9*(isTerrainSwamp(posA)?5:1)
      //     }
      // }
      // if(block){
      //     cm.set(pos.x,pos.y,255)
      // }else{
      cm.set(pos.x, pos.y, cost);
      // }
    }
  }
}
function ifAllAtCorrectPos(cres: Cre[]): boolean {
  let rtn: boolean = true;
  for (let cre of cres) {
    if (!atCorrectPos(cre)) {
      rtn = false;
    }
  }
  return rtn;
}
function rpSearchPath(): Pos[] {
  let sRtn = searchPath(assemblePos, targetAssemblePos, { costMatrix: cm });
  let path = sRtn.path;
  return path;
}
function moveToEnemySpawn() {
  if (validPos(assemblePos)) {
    let path = rpSearchPath();
    drawPoly(path, 0.7, "#ee22ee");
    assemblePos = path[0];
    SA(assemblePos, "GO GO GO!");
  }
}
function getRpMiddle(): Pos | undefined {
  const rpLen = getRobotParts().length;
  const middle = Math.ceil(rpLen / 2);
  const posRP = getRobotParts()[middle - 1];
  if (validPos(posRP)) {
    return { x: posRP.x, y: posRP.y };
  } else {
    return enemySpawn;
  }
}
function getRpFirst(): Cre | undefined {
  let rp = findRpByIndex(1);
  let n = 1;
  while (!rp) {
    n++;
    if (n == 7) {
      break;
    }
    rp = findRpByIndex(n);
  }
  return rp;
}
function ifRangeBlock_Rps(pos: Pos): boolean {
  let rtn: boolean = false;
  let rangePoss = getRangePoss(pos, 1);
  for (let rangePos of rangePoss) {
    let ls = overallMap.get(rangePos);
    let frtn = ls.find(
      (i) =>
        i instanceof StructureRampart ||
        i instanceof StructureWall ||
        i instanceof StructureSpawn
    );
    if (frtn || isTerrainWall(rangePos)) {
      rtn = true;
    }
  }
  return rtn;
}
function findRangePosNotBlock(pos: Pos): Pos {
  let startTime = ct();
  if (!ifRangeBlock_Rps(pos)) {
    return { x: pos.x, y: pos.y };
  }
  let range = 1;
  while (range < 100) {
    let rangePoss = getRangePoss(pos, range);
    for (let rangePos of rangePoss) {
      if (!ifRangeBlock_Rps(rangePos)) {
        return rangePos;
      }
    }
    range++;
  }
  pt("findRangePosNotBlock", startTime);
  return pos;
}
function allReady(rps: Cre[]): boolean {
  return ifAllAtCorrectPos(rps) && ifAllMovable(rps);
}
function controlRPs() {
  //if all RPS borned
  if (allRPprepared) {
    SA(assemblePos, "currentMode=" + useRobotMode);
    SA(assemblePos, "currentShape=" + currentShape.toString());
    let rps = getFriends().filter((i) => i.role == robotPart);
    //scan shape worth
    const warnRange = 7;
    // const warnChangeModeRange=7
    const safeChangeModeRange = 9;
    let tars: GameObject[] = (<GameObject[]>getOppoUnits())
      .concat(getWalls())
      .filter((i) => MGR(i, assemblePos) <= warnRange);
    let ifWarn: boolean = false;
    //jduge if trans standard
    for (let rp of rps) {
      if (hasEnemyArmyAround(rp, 3)) {
        ifWarn = true;
      }
    }
    let tarsSafe: GameObject[] = (<GameObject[]>getOppoUnits())
      .concat(getWalls())
      .filter((i) => MGR(i, assemblePos) <= safeChangeModeRange);
    const ens = getEnemies().filter(
      (i) =>
        i.getBodiesNum(ATTACK) > 0 &&
        hasFriendAround(i, 1) &&
        MGR(i, assemblePos) <= 2
    );
    const forces = sumForceByArr(ens);
    const rpNum = getRobotParts().length;
    const ensAround2 = getEnemies().filter(
      (i) =>
        i.getBodiesNum(ATTACK) > 0 &&
        hasFriendAround(i, 2) &&
        MGR(i, assemblePos) <= 3
    );
    const forcesEnsAround2 = sumForceByArr(ensAround2);
    const forceLimit = Math.max(1, 15 * (rpNum / 6));
    const forceAround2Limit = Math.max(1, 30 * (rpNum / 6));
    //if snake
    if (useRobotMode === snakeMode) {
      if (ifWarn) {
        useRobotMode = standardMode;
      } else {
        const f = getRpMiddle();
        if (f) {
          assemblePos = findRangePosNotBlock(f);
        }
      }
      //if standard
    } else if (useRobotMode === standardMode) {
      if (tarsSafe.length == 0) {
        useRobotMode = snakeMode;
      } else if (forces > forceLimit || forcesEnsAround2 > forceAround2Limit) {
        useRobotMode = splitMode;
      }
      //if split
    } else if (useRobotMode === splitMode) {
      if (
        forces <= 0.25 * forceLimit ||
        (forcesEnsAround2 <= 0.25 * forceAround2Limit && rpNum >= 3)
      ) {
        useRobotMode = standardMode;
      }
    }
    //if all at correct pos
    if (allReady(rps)) {
      if (useRobotMode === standardMode) {
        //every things in warn range
        for (let tar of tars) {
          let dPos = minusVector(tar, assemblePos);
          let dir = getDirection(dPos.x, dPos.y);
          let range = MGR(tar, assemblePos);
          let rangeW = warnRange + 1 - range;
          SA(tar, "dir=" + dir + "rangeW=" + rangeW);
          if (tar instanceof Creep) {
            let ene: Cre = <Cre>tar;
            let aNum = ene.getHealthyBodies(ATTACK).length;
            let rNum = ene.getHealthyBodies(RANGED_ATTACK).length;
            //get direction of it
            if (valid(dir)) {
              let shapeA: Shape = getShapeConstByRotate(dir);
              let dwA: number;
              if (range <= 2) {
                dwA = 0.8 * 3 * (aNum + 2) * rangeW;
              } else {
                dwA = 0.5 * 3 * aNum * rangeW;
              }
              SA(tar, "dwA=" + dwA);
              shapeA.we.increase(dwA);
              //
              let shapeR: Shape = getShapeConstByRotate(
                rotateDirectionCW(dir, 4)
              );
              let dwR: number;
              if (range <= 2) {
                dwR = 0;
              } else if (range <= 4) {
                dwR = 1.5 * 1 * (rNum + 1) * rangeW;
              } else {
                dwR = 1 * 1 * rNum * rangeW;
              }
              //increase shape worth
              shapeR.we.increase(dwR);
              SA(tar, "dwR=" + dwR);
            }
          } else {
            if (valid(dir)) {
              let shapeA: Shape = getShapeConstByRotate(dir);
              let dwAU: number;
              if (range <= 2) {
                dwAU = 1 * 1 * rangeW;
              } else {
                dwAU = 0;
              }
              shapeA.we.increase(dwAU);
              SA(tar, "dwAU=" + dwAU);
            }
          }
        }
        //decide best shape
        let bestShape = getBestShape();
        SA(assemblePos, "bestShape=" + bestShape.toString());
        //if is now shape ,move on
        if (bestShape.equal(currentShape)) {
          moveToEnemySpawn();
          //transform
        } else {
          SA(assemblePos, "changeShape");
          transformTo(bestShape);
        }
      }
    } else {
      SA(assemblePos, "wait fatigue");
    }
  }
}
function minusDirection(
  dir1: DirectionConstant,
  dir2: DirectionConstant
): number {
  return ((dir1 - dir2 + 3 + 800) % 8) - 3;
}
function plusDirection(
  dir1: DirectionConstant,
  dir2: number
): DirectionConstant {
  return <DirectionConstant>(((dir1 + dir2 - 1 + 800) % 8) + 1);
}
function getRobotParts(): Cre[] {
  return getFriends().filter((i) => i.role == robotPart);
}
function findRpByIndex(index: number): Cre | undefined {
  return getRobotParts().find((i) => getRPInd(i) === index);
}
function exchangeIndexByIndex(i1: number, i2: number) {
  let cre1 = findRpByIndex(i1);
  let cre2 = findRpByIndex(i2);
  if (cre1) setRPInd(cre1, i2);
  if (cre2) setRPInd(cre2, i1);
}
function ext1346() {
  exchangeIndexByIndex(1, 3);
  exchangeIndexByIndex(4, 6);
}
function exchangeIndex(cre1: Cre, cre2: Cre) {
  let temp = getRPInd(cre1);
  setRPInd(cre1, getRPInd(cre2));
  setRPInd(cre2, temp);
}
function transformTo(tarShape: Shape) {
  if (!tarShape.equal(currentShape)) {
    let midShape: Shape | undefined;
    let dd = minusDirection(tarShape.rotate, currentShape.rotate);
    let dRight: Direct4 = <Direct4>plusDirection(currentShape.rotate, 2);
    let dTop: Direct4 = <Direct4>plusDirection(currentShape.rotate, 0);
    let dLeft: Direct4 = <Direct4>plusDirection(currentShape.rotate, -2);
    let dBottom: Direct4 = <Direct4>plusDirection(currentShape.rotate, 4);
    //
    if (currentShape.name == shapeType_normal) {
      if (tarShape.name == shapeType_normal) {
        if (dd == 2) {
          midShape = new Shape(shapeType_corner, dRight);
        } else if (dd == -2) {
          midShape = new Shape(shapeType_corner, dTop);
        } else if (dd == 4) {
          midShape = new Shape(shapeType_beta, dBottom);
          SA(assemblePos, "ext1");
          ext1346();
        }
      } else if (tarShape.name == shapeType_corner) {
        if (dd == -2) {
          midShape = new Shape(shapeType_beta, dBottom);
          SA(assemblePos, "ext2");
          ext1346();
        } else if (dd == 4) {
          midShape = new Shape(shapeType_beta, dBottom);
          SA(assemblePos, "ext3");
          ext1346();
        }
      }
    } else if (currentShape.name == shapeType_beta) {
      if (tarShape.name == shapeType_normal) {
        if (dd == 2) {
          midShape = new Shape(shapeType_corner, dRight);
        } else if (dd == -2) {
          midShape = new Shape(shapeType_corner, dTop);
        } else if (dd == 4) {
          SA(assemblePos, "extA");
          ext1346();
        }
      } else if (tarShape.name == shapeType_corner) {
        if (dd == -2) {
          midShape = new Shape(shapeType_normal, dBottom);
          SA(assemblePos, "ext4");
          ext1346();
        } else if (dd == 4) {
          midShape = new Shape(shapeType_normal, dBottom);
          SA(assemblePos, "ext5");
          ext1346();
        }
      }
    } else if (currentShape.name == shapeType_corner) {
      if (tarShape.name == shapeType_normal) {
        if (dd == 2) {
          midShape = new Shape(shapeType_beta, dLeft);
        } else if (dd == 4) {
          midShape = new Shape(shapeType_beta, dTop);
        }
      } else if (tarShape.name == shapeType_corner) {
        if (dd == 2) {
          midShape = new Shape(shapeType_normal, dTop);
        } else if (dd == -2) {
          midShape = new Shape(shapeType_normal, dLeft);
        } else if (dd == 4) {
          midShape = new Shape(shapeType_beta, dTop);
        }
      }
    }
    //
    if (midShape) {
      currentShape = new Shape(midShape.name, midShape.rotate);
    } else {
      currentShape = new Shape(tarShape.name, tarShape.rotate);
    }
    SA(assemblePos, "transToShape=" + currentShape.toString());
    for (let i = 1; i <= 6; i++) {
      let pos = assemblePoint_Robot(i, assemblePos);
      SA(pos, "should be=" + i);
    }
  }
}
let robotStrategyTick: number = 0;
export function useRobotStrategy() {
  let st = addStrategyTick();
  let roundSpawnPoss = getRangePoss(spawn, 2);
  for (let pos of roundSpawnPoss) {
    // SA(pos,"cost="+ramSaveCostMatrix?.get(pos.x,pos.y))
  }
  SA(spawn, "robotStrategyTick=" + robotStrategyTick);
  SA(spawn, "enemyAWeight()=" + enemyAWeight());
  SA(spawn, "everLastingSnakeMode=" + everLastingSnakeMode);
  SA(spawn, "guessPlayer=" + getGuessPlayer().name);
  //judge Tigga
  if (tick <= 100) {
    const en = getEnemies().find(
      (i) =>
        i.getBodiesNum(CARRY) === 3 &&
        i.getBodiesNum(WORK) === 2 &&
        i.getBodiesNum(MOVE) === 5
    );
    if (en) {
      if (Tigga.posibility < 0.9) {
        Tigga.posibility = 0.9;
      }
    }
  }
  if (tick <= 150) {
    const en = getEnemies().find(
      (i) =>
        i.getBodiesNum(ATTACK) === 6 &&
        i.getBodiesNum(MOVE) === 10 &&
        getSurfaceBody(i).type === ATTACK
    );
    if (en) {
      if (Tigga.posibility < 0.8) {
        Tigga.posibility = 0.8;
      }
    }
  }
  //judge Capta
  if (tick <= 100) {
    const en = getEnemies().find(
      (i) =>
        (i.getBodiesNum(CARRY) === 3 || i.getBodiesNum(CARRY) === 4) &&
        i.getBodiesNum(WORK) === 1 &&
        i.getBodiesNum(MOVE) === 5
    );
    if (en) {
      if (Capta.posibility < 0.9) {
        Capta.posibility = 0.9;
      }
    }
  }
  if (tick <= 120) {
    const en = getEnemies().find(
      (i) =>
        i.getBodiesNum(CARRY) === 6 &&
        i.getBodiesNum(WORK) === 2 &&
        i.getBodiesNum(MOVE) === 10
    );
    if (en) {
      if (Capta.posibility < 1) {
        Capta.posibility = 1;
      }
    }
  }
  //strategy start
  //initial costMatrix for 3 size group
  setTargetAssemblePos();
  //buildRoads for base defending
  if (getMyConstructionSites().length <= 7) {
    const possAround = getRangePoss(spawn, 1).filter(
      (i) => MGR(i, spawn) !== 0
    );
    for (let pos of possAround) {
      const b = createCS(pos, StructureRoad, 10);
      if (b) break;
    }
  }
  if (st == 1) {
    //for base harve
    spawnCreep(harvesterBody, harvester); //
    spawnCreep(harvesterBody, harvester); //
    buildBaseDefending();
    //
    //set assemblePos
    if (!allRPprepared) {
      let lr = multiplyVector(sasVariables.leftVector(), -3);
      assemblePos = plusVector(spawn, lr);
    }
  }
  //supply harvester
  if (st >= 2 && st <= 300) {
    let aliveHarvesterNum = getFriends().filter(
      (i) => i !== spawn.isSpawning && i.role === harvester
    ).length;
    let inListHarvesterNum = spawnList.filter(
      (i) => i.role === harvester
    ).length;
    let isSpawningNum = spawn.isSpawning?.role === harvester ? 1 : 0;
    let harNum = aliveHarvesterNum + inListHarvesterNum + isSpawningNum;
    if (harNum < 2) {
      spawnCreepInFront(harvesterBody, harvester);
    }
  }
  // if(st==25){
  //     spawnCreep(GMB(5).concat([ATTACK]),extAttacker)
  // }
  // if(st===25){
  //     let pos=plusVector(spawn,multiplyVector(sasVariables.leftVector(),2))
  //     SA(pos,"create ext")
  //     createConstructionSiteAndCancel(pos,StructureExtension,10,false)
  // }
  if (st == 60) {
    //1
    // //350+560+50
    // spawnCreep(GMB(4).concat(GB(ATTACK,4),GMB(3),GB(ATTACK,3),[MOVE]),robotPart,{ind:1});//
    spawnCreep(GMB(5).concat(GAB(3), GMB(4), GAB(3), GMB()), robotPart, {
      ind: 1,
    }); //
  }
  if (st == 110) {
    //2
    //300+150+150+320+50
    spawnCreep(GMB(5).concat(GAB(3), GMB(4), GAB(3), GMB()), robotPart, {
      ind: 2,
    }); //
    // spawnCreep(GMB(5).concat([RANGED_ATTACK],GMB(3),GB(ATTACK,4),[MOVE]),robotPart,{ind:2});//
  }
  if (st == 160) {
    //3
    spawnCreep(GMB(5).concat(GAB(3), GMB(4), GAB(3), GMB()), robotPart, {
      ind: 3,
    }); //
  }
  const aRate = enemyAWeight();
  if (st == 210) {
    //4
    if (getGuessPlayer() === Capta) {
      if (useHarvestStrategy)
        spawnCreep(
          GMB(6).concat(GB(RANGED_ATTACK, 3), [WORK, CARRY, MOVE]),
          robotPart,
          { ind: 4 }
        );
      //
      else if (aRate > 0.8) {
        //450+150+320+50
        spawnCreep(GMB(5).concat(GAB(3), GMB(4), GAB(3), GMB()), robotPart, {
          ind: 4,
        }); //
      } else if (aRate > 0.4) {
        //400+300+160+50
        spawnCreep(GMB(9).concat(GRB(2), GAB(2), GMB()), robotPart, { ind: 4 }); //
      } else {
        //400+450+80+50
        spawnCreep(GMB(6).concat(GRB(4), GMB()), robotPart, { ind: 4 }); //
      }
    } else {
      if (aRate > 0.7) {
        //400+300+160+50
        spawnCreep(GMB(9).concat(GRB(2), GAB(2), GMB()), robotPart, { ind: 4 }); //
      } else {
        //400+450+80+50
        spawnCreep(GMB(6).concat(GRB(4), GMB()), robotPart, { ind: 4 }); //
      }
    }
  }
  if (st == 260) {
    //5
    if (getGuessPlayer() === Capta) {
      if (aRate > 0.8) {
        //20 40
        //450+240+250+50
        spawnCreep(GMB(9).concat(GAB(3), GHB(1), GMB()), robotPart, { ind: 5 }); //
      } else {
        //200+750+50
        spawnCreep(GMB(4).concat(GHB(3), GMB()), robotPart, { ind: 5 }); //
      }
    } else {
      //200+750+50
      spawnCreep(GMB(4).concat(GHB(3), GMB()), robotPart, { ind: 5 }); //
    }
  }
  if (st == 310) {
    //6
    if (getGuessPlayer() === Capta) {
      if (useHarvestStrategy)
        spawnCreep(
          GMB(6).concat(GB(RANGED_ATTACK, 3), [WORK, CARRY, MOVE]),
          robotPart,
          { ind: 6 }
        );
      //
      else if (aRate > 0.8) {
        //450+150+320+50
        spawnCreep(GMB(5).concat(GAB(3), GMB(4), GAB(3), GMB()), robotPart, {
          ind: 6,
        }); //
      } else if (aRate > 0.4) {
        //400+300+160+50
        spawnCreep(GMB(9).concat(GRB(2), GAB(2), GMB()), robotPart, { ind: 6 }); //
      } else {
        //400+450+80+50
        spawnCreep(GMB(6).concat(GRB(4), GMB()), robotPart, { ind: 6 }); //
      }
    } else {
      if (aRate > 0.7) {
        //400+300+160+50
        spawnCreep(GMB(9).concat(GRB(2), GAB(2), GMB()), robotPart, { ind: 6 }); //
      } else {
        //400+450+80+50
        spawnCreep(GMB(6).concat(GRB(4), GMB()), robotPart, { ind: 6 }); //
      }
    }
  }
  if (st == 350) {
    //defender
    spawnCreep([ATTACK, ATTACK, RANGED_ATTACK, MOVE], defender_rampart);
    spawnCreep([ATTACK, ATTACK, RANGED_ATTACK, MOVE], defender_rampart);
  }
  //rebuild ramparts
  const transRebuildTime = 600;
  if (st >= 360 && st <= transRebuildTime) {
    reBuildBaseRampart();
    reBuildCrossRampart();
  } else if (st > transRebuildTime + 1) {
    reBuildAroundRampart();
  }
  if (st === transRebuildTime) {
    let leftRate = sasVariables.leftRate();
    createCS({ x: spawn.x - leftRate, y: spawn.y + 1 }, StructureRampart, 9);
    createCS({ x: spawn.x - leftRate, y: spawn.y - 1 }, StructureRampart, 9);
    createCS({ x: spawn.x + leftRate, y: spawn.y + 1 }, StructureRampart, 8);
    createCS({ x: spawn.x + leftRate, y: spawn.y - 1 }, StructureRampart, 8);
  }
  if (st >= 1100) {
    if (spawnList.length === 0 && getEnergy(spawn) >= 700) {
      spawnCreep(
        [ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE],
        defender_rampart
      );
    }
  }
  //control robot parts
  if (st === 1 || st % 10 === 0) {
    initCM();
  }
  controlRPs();
}

//red ball rush
@@ -1,422 +0,0 //role
let extAttacker: Role = new Role("extAttacker", extAttackerControl);
let blocker: Role = new Role("blocker", blockerControl);
//var
let extAttackerSpawned: boolean = false;
let startGateSeted: boolean = false;
//const
const biasm1 = 0.9;
const bias0 = 0.8;
const bias1 = 0.6;
const bias2 = 0.3;

//rbr
function blockerControl(cre: Cre) {}
function extAttackerControl(cre: Cre) {
  cre.melee();
  if (cre.flee(13, 26)) {
  } else {
    let opExts = getOppoExtensions();
    let builders = getEnemies().filter((i) => i.getBodies(WORK).length > 0);
    let ext = cre.findClosestByRange(opExts);
    let extT = 2 * (ext ? 1 / (MGR(ext, cre) + 1) : 0);
    let buider = cre.findClosestByRange(builders);
    let buiT = buider ? 1 / (MGR(buider, cre) + 1) : 0;
    if (ext && extT > buiT) {
      cre.MTJ(ext);
    } else if (buider && buiT > extT) {
      cre.MTJ(buider);
    }
  }
}
/**
 * decide spawn which type of patient spawn attacker
 */
export function decideSpawnPA(ind: number) {
  //patient attacker
  let aRate = enemyAWeight();
  if (getGuessPlayer() === Dooms) {
    spawnCreep(
      GMB(9).concat(GB(ATTACK, 5)).concat([MOVE]),
      patientSpawnAttacker
    );
  } else if (getGuessPlayer() === MathI) {
    if (aRate > bias0) {
      spawnCreep(
        GMB(11).concat(GB(ATTACK, 3)).concat([MOVE]),
        patientSpawnAttacker
      );
    } else if (aRate > bias1) {
      spawnCreep(
        GMB(11).concat(GB(ATTACK, 3)).concat([MOVE]),
        patientSpawnAttacker
      );
    } else if (aRate > bias2) {
      spawnCreep(
        GMB(13).concat(GB(ATTACK, 2)).concat([MOVE]),
        patientSpawnAttacker
      );
    } else {
      //750+160+50
      spawnCreep(
        GMB(13).concat(GB(ATTACK, 2)).concat([MOVE]),
        patientSpawnAttacker
      );
    }
    //standard
  } else {
    if (aRate > biasm1) {
      if (ind === 0) {
        spawnCreep(GMB(9).concat(GAB(6), GMB()), patientSpawnAttacker);
      } else {
        spawnCreep(GMB(9).concat(GAB(6), GMB()), patientSpawnAttacker);
      }
    } else if (aRate > bias1) {
      if (ind == 0) {
        spawnCreep(
          GMB(11).concat(GB(ATTACK, 3)).concat([MOVE]),
          patientSpawnAttacker
        );
      } else {
        spawnCreep(
          GMB(11).concat(GB(ATTACK, 4)).concat([MOVE]),
          patientSpawnAttacker
        );
      }
    } else if (aRate > bias2) {
      spawnCreep(
        GMB(13).concat(GB(ATTACK, 3)).concat([MOVE]),
        patientSpawnAttacker
      );
    } else {
      //750+160+50
      spawnCreep(
        GMB(14).concat(GB(ATTACK, 2)).concat([MOVE]),
        patientSpawnAttacker
      );
    }
  }
}
export function useRedBallRush() {
  //set spawn dps
  setSpawnDps(120);
  setMoveMapSetRate(0.2);
  setEnSpawnAroundCost(50);
  SA(spawn, "guessPlayer=" + getGuessPlayer().name);
  SA(spawn, "enemyAWeight()=" + enemyAWeight());
  if (tick === 1) {
    //for base harve
    spawnCreep(harvesterBody, harvester); //
    spawnCreep(harvesterBody, harvester); //
  }
  if (!playerJudgedCapta) {
    if (tick <= 100) {
      const en = getEnemies().find(
        (i) =>
          (i.getBodiesNum(CARRY) === 3 || i.getBodiesNum(CARRY) === 4) &&
          i.getBodiesNum(WORK) === 1 &&
          i.getBodiesNum(MOVE) === 5
      );
      if (en) {
        set_playerJudgedCapta(true);
        Capta.posibility = 1;
      }
    }
    if (tick <= 120) {
      const en = getEnemies().find(
        (i) =>
          i.getBodiesNum(CARRY) === 6 &&
          i.getBodiesNum(WORK) === 2 &&
          i.getBodiesNum(MOVE) === 10
      );
      if (en) {
        set_playerJudgedCapta(true);
        Capta.posibility = 1;
      }
    }
  }
  //judge doom
  if (!playerJudgedDooms) {
    if (tick >= 25 && tick <= 120) {
      let en = getEnemies().find((i) => i.getBodies(WORK).length >= 3);
      if (en) {
        set_playerJudgedDooms(true);
        Dooms.posibility = 1;
      }
    }
  }
  //judge mathi
  if (!playerJudgeMathI) {
    if (tick >= 40 && tick <= 250) {
      let ens = getEnemies().filter((i) => !i.isArmy());
      if (ens.length == 1) {
        let en = ens[0];
        //CMMWCM
        if (
          en.body[0].type == CARRY &&
          en.body[1].type == MOVE &&
          en.body[2].type == MOVE &&
          en.body[3].type == WORK &&
          en.body[4].type == CARRY &&
          en.body[5].type == MOVE
        ) {
          set_playerJudgeMathI(true);
          MathI.posibility = 1;
        }
      }
    }
    if (tick >= 60 && tick <= 140) {
      let en = getEnemies().find(
        (i) =>
          i.getBodies(RANGED_ATTACK).length == 5 &&
          i.getBodies(MOVE).length == 5
      );
      if (en) {
        // playerJudgeMathI=true
        MathI.posibility = 0.9;
      }
    }
    let en = getEnemies().find(
      (i) => i.getBodies(MOVE).length == 20 && i.hitsMax == 2000
    );
    if (en) {
      set_playerJudgeMathI(true);
      MathI.posibility = 1;
    }
  } else {
    setPlayerMathI(true);
  }
  if (tick == 40) {
    //3rd
    decideSpawnPA(0);
  }
  if (tick == 80) {
    //4th
    decideSpawnPA(1);
  }
  if (tick == 110) {
    //5th
    decideSpawnPA(2);
  }
  if (tick == 150) {
    //leader
    let aw = enemyAWeight();
    if (getGuessPlayer() == Dooms) {
      //200+720+50
      spawnCreep(GMB(4).concat(GAB(9)).concat([MOVE]), patientSpawnAttacker);
    } else if (getGuessPlayer() == MathI) {
      //} if(getGuessPlayer()==){
      if (aw > bias1) {
        //200+560+150+50
        spawnCreep(
          GMB(4).concat(GAB(7)).concat([RANGED_ATTACK, MOVE]),
          patientSpawnAttacker
        );
      } else {
        //150+320+450+50
        spawnCreep(
          GMB(3)
            .concat(GAB(4))
            .concat([RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE]),
          patientSpawnAttacker
        );
      }
    } else {
      if (aw > bias0) {
        //200+720+50
        spawnCreep(GMB(4).concat(GAB(9), GMB()), patientSpawnAttacker);
      } else if (aw > bias1) {
        //200+560+150+50
        spawnCreep(
          GMB(4).concat(GB(ATTACK, 7)).concat([RANGED_ATTACK, MOVE]),
          patientSpawnAttacker
        );
      } else {
        //200+400+300+50
        spawnCreep(
          GMB(5)
            .concat(GB(ATTACK, 5))
            .concat([RANGED_ATTACK, RANGED_ATTACK, MOVE]),
          patientSpawnAttacker
        );
      }
    }
  }
  if (tick == 190) {
    //second
    let aw = enemyAWeight();
    if (getGuessPlayer() == Dooms) {
      //300+640+50
      spawnCreep(
        GMB(6).concat(GB(ATTACK, 8)).concat([MOVE]),
        patientSpawnAttacker
      );
    } else if (getGuessPlayer() == MathI) {
      if (aw > bias1) {
        spawnCreep(
          GMB(4).concat(GB(ATTACK, 3)).concat([RANGED_ATTACK, HEAL, MOVE]),
          patientSpawnAttacker
        );
      } else {
        //100+160+150+500+50
        spawnCreep(
          GMB(2)
            .concat(GB(ATTACK, 2))
            .concat([RANGED_ATTACK, HEAL, HEAL, MOVE]),
          patientSpawnAttacker
        );
      }
      //standard
    } else if (getGuessPlayer() === Capta) {
      if (aw > biasm1) {
        //300+640+50
        spawnCreep(GMB(6).concat(GAB(8), GMB()), patientSpawnAttacker);
      } else if (aw > bias1) {
        spawnCreep(
          GMB(4).concat(GAB(4), GRB(), GMB(), GHB()),
          patientSpawnAttacker
        );
      } else {
        spawnCreep(
          GMB(6).concat(GAB(3), GRB(), GMB(), GHB()),
          patientSpawnAttacker
        );
      }
    } else {
      if (aw > bias1) {
        spawnCreep(GMB(4).concat(GAB(6), GMB(), GHB()), patientSpawnAttacker);
      } else {
        spawnCreep(GMB(9).concat(GAB(3), GMB(), GHB()), patientSpawnAttacker);
      }
    }
  }
  if (tick === 230) {
    //last third
    let aRate = enemyAWeight();
    if (aRate > bias1) {
      //350+320+50    16 40
      spawnCreep(GMB(7).concat(GAB(4), GMB()), patientSpawnAttacker);
    } else {
      //450+240+50    20 30
      spawnCreep(GMB(9).concat(GAB(3), GMB()), patientSpawnAttacker);
    }
  }
  if (tick === 270) {
    //last second
    let aw = enemyAWeight();
    if (getGuessPlayer() == Dooms) {
      //250+400+250+50
      spawnCreep(
        GMB(9).concat(GB(ATTACK, 6)).concat([MOVE]),
        patientSpawnAttacker
      );
    } else if (getGuessPlayer() === Capta) {
      if (aw > biasm1) {
        //250+400+250+50
        spawnCreep(GMB(7).concat(GAB(7), GMB()), patientSpawnAttacker);
      } else {
        //400+320+250+50
        spawnCreep(GMB(7).concat(GAB(4), GMB(), GHB()), patientSpawnAttacker);
      }
      //Tigga and other
    } else {
      //400+320+250+50
      spawnCreep(GMB(7).concat(GAB(4), GMB(), GHB()), patientSpawnAttacker);
    }
  }
  if (tick === 320) {
    //last one
    let aRate = enemyAWeight();
    if (getGuessPlayer() == Dooms) {
      //250+720
      spawnCreep(GMB(5).concat(GB(ATTACK, 9)), patientSpawnAttacker);
    } else if (getGuessPlayer() == MathI) {
      if (aRate > bias1) {
        //400+400+150+50
        spawnCreep(
          GMB(8).concat(GB(ATTACK, 5)).concat([RANGED_ATTACK]).concat([MOVE]),
          patientSpawnAttacker
        );
      } else {
        //450+160+300+50
        spawnCreep(
          GMB(9)
            .concat([ATTACK, ATTACK, RANGED_ATTACK, RANGED_ATTACK])
            .concat([MOVE]),
          patientSpawnAttacker
        );
      }
    } else if (getGuessPlayer() === Capta) {
      if (aRate > bias0) {
        //400+480+50
        spawnCreep(
          GMB(9).concat(GB(ATTACK, 6)).concat([MOVE]),
          patientSpawnAttacker
        );
      } else if (aRate > bias1) {
        //550+400+50
        spawnCreep(
          GMB(11).concat(GB(ATTACK, 5)).concat([MOVE]),
          patientSpawnAttacker
        );
      } else {
        //550+160+150+50
        spawnCreep(
          GMB(12).concat([ATTACK, ATTACK, RANGED_ATTACK]).concat([MOVE]),
          patientSpawnAttacker
        );
      }
      //standard
    } else {
      spawnCreep(GMB(10).concat(GAB(3), GRB(), GMB()), patientSpawnAttacker);
    }
  }
  //set start gate
  let psas: Cre[] = getFriends().filter(
    (i) => i.role == patientSpawnAttacker && i.isBirth
  );
  if (!startGateSeted && (tick === 385 || psas.length >= PSATotalNum)) {
    startGateSeted = true;
    sasVariables.resetStartGate();
  }
  if (tick === 380) {
    //first defender
    const spEn = getEnemyArmies().find((i) => MGR(i, spawn) <= 6);
    const aRate = enemyAWeight();
    if (spEn) {
      if (aRate > 0.6) {
        //50+100+240
        spawnCreep(GTB(5).concat(GMB(2), GAB(3)), toughDefender);
      } else {
        spawnCreep(GTB(5).concat(GMB(2), GAB(), GRB()), toughDefender);
      }
    } else {
      if (aRate > 0.6) {
        spawnCreep(GTB(15).concat(GMB(3), GAB(3)), toughDefender);
      } else {
        spawnCreep(GTB(15).concat(GMB(3), GAB(), GRB()), toughDefender);
      }
    }
  }
  if (tick >= 600 && spawnList.length === 0) {
    //250+160
    spawnCreep(GMB(5).concat(GAB(2)), spawnAttacker);
  }
}
